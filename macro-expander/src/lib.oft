(module macro-expander
  [expand-modules])

(import macro-expander/modules
  [module-name])
(import ministd/data/tree-set
  [list->set set-has?])

; Returns whether the value is macro-expandable with any of the given macros.
(intrinsics:defn expandable? (value macros)
  (def s (as-shl value))
  (if s
    (some? (assoc s macros))
    false))

; Macro-expands an arbitrary value, returning the expanded value. Will panic on defmacro.
(intrinsics:defn macro-expand (value macros)
  (if (shl? 'defmacro value)
    (panic "defmacro forms must appear at the top level of a module"))
  (if (expandable? value macros)
    (progn
      (def macro (assoc (car value) macros))
      (panic (list 'todo macro-expand macro value)))
    value))

; Performs macro-expansion on a single decl. Note that multiple decls may result from expanding a
; single one, due to top-level progn expansion. Returns a list
; (EXPANDED-DECLS NEW-INTERP-ENV NEW-INTERP-MACROS).
(intrinsics:defn expand-decl (decl interp-env interp-macros top-level)
  (if (shl? 'defmacro decl)
    (panic '(todo expand defmacro))
    (if (and top-level (shl? 'progn decl))
      (panic '(todo expand top-level progn))
      (if (expandable? decl interp-macros)
        (expand-decl (macro-expand decl interp-macros) interp-env interp-macros top-level)
        (if (shl? 'def decl)
          (panic '(todo | def-decl))
          (if (shl? 'defn decl)
            (panic '(todo | defn-decl))
            (panic (cons 'not-a-decl decl))))))))

; Performs macro-expansion on an arbitrary number of decls. Returns a list
; (EXPANDED-DECLS INTERP-ENV INTERP-MACROS).
(intrinsics:defn expand-decls (decls interp-env interp-macros)
  (intrinsics:defn loop (decls acc interp-env interp-macros)
    (if (nil? decls)
      (list (reverse acc) interp-env interp-macros)
      (progn
        (def tmp (expand-decl (car decls) interp-env interp-macros true))
        (loop
          (cdr decls)
          (cons (nth 0 tmp) acc)
          (nth 1 tmp)
          (nth 2 tmp)))))
  (loop decls nil interp-env interp-macros))

; Expands all the declarations in a module, returning a list of expanded modules.
(intrinsics:defn expand-module (target-module mod-srcs mods)
  ; The source of the target module.
  (def mod-src (expect
    (find \(equals (module-name $) target-module) mod-srcs)
    (string-append "Module not found: " (symbol->string target-module))))
  ; All import decls.
  (def imports (find-imports mod-src))
  ; A list of modules not yet in the mods assoc.
  (def missing-modules (filter
    \(none? (assoc $ mods))
    (map
      \(nth 1 $)
      imports)))
  (if (nil? missing-modules)
    ; If no modules are missing, build the environment and expand the declarations inside the
    ; module. Then, return the environment, as created from only the declarations inside the module
    ; (i.e. not including imports).
    (progn
      (def tmp (build-initial-env imports mods))
      (def interp-env (fst tmp))
      (def interp-macros (snd tmp))
      (def decls (find-decls mod-src))
      (expand-decls decls interp-env interp-macros))
    ; If there are missing modules, try expanding the first one, then try again with that one
    ; added.
    (progn
      (def new-mods (expand-module (car missing-modules) mod-srcs mods))
      (expand-module target-module mod-srcs new-mods))))

; Builds an initial environment from a list of import decls and an assoc of expanded module
; environments. Returns a pair (INTERP-ENV INTERP-MACROS).
(intrinsics:defn build-initial-env (imports mods)
  (def tmp (map \(process-import $ mods) imports))
  (if (nil? tmp)
    (pair nil nil)
    (panic (list 'todo (list 'build-initial-env imports 'mods)))))

; Returns all the declarations from a module. (Really, just skips the module form and imports.)
(intrinsics:defn find-decls (m)
  (skip-while \(shl? 'import $) (cdr m)))

; Returns all the import forms from a module.
(intrinsics:defn find-imports (m)
  (take-while \(shl? 'import $) (cdr m)))

; Takes an import form and an assoc of already-expanded modules. Returns a list of pairs, where the
; fst is the imported value name and the snd is an either.  The left of the either is a value from
; interpreting the module. The right of the either is a function that runs the macro.
(intrinsics:defn process-import (imp mods)
  (def mod-name (nth 1 imp))
  (def plain-imports (vector->list (nth 2 imp)))
  (def attrs (skip 3 imp))

  (def m (expect
    (assoc mod-name mods)
    "Module not found, but this should've been caught already?"))

  (def no-import-decls (list->set (option->nullable
    (assoc 'no-import-decl attrs))))
  (def no-import-macros (list->set (option->nullable
    (assoc 'no-import-macro attrs))))

  (map
    \(progn
      (def f
        (if (set-has? $ no-import-decls)
          (if (set-has? $ no-import-macros)
            (panic (string-concat (list
              "Symbol "
              (symbol->string $)
              " was excluded from both decl and macro imports (from module "
              (symbol->string mod-name)
              ")")))
            process-import-macro)
          (if (set-has? $ no-import-macros)
            process-import-decl
            process-import-either)))
      (expect (f mod-name $ mods)
        (string-concat
          "Couldn't import "
          (symbol->string $)
          " from "
          (symbol->string mod-name))))
    plain-imports))

(intrinsics:defn process-import-decl (m name mods)
  (panic '(todo | process-import-decl)))

(intrinsics:defn process-import-either (m name mods)
  (def decl (process-import-decl m name mods))
  (def macro (process-import-macro m name mods))
  (panic '(todo | process-import-either)))

(intrinsics:defn process-import-macro (m name mods)
  (panic '(todo | process-import-macro)))

(intrinsics:defn expand-modules (mods-srcs)
  (expand-module 'main mods-srcs nil))
