(module macro-expander/packages
  [load-packages traverse-modules])

(import macro-expander/packages/load
  load-package-from)
(import macro-expander/packages/type
  binary-component library-component package)
(import ministd/data/tree-set
  empty-set)
(import ministd/monad
  monad-for)
(import ministd/monad/state
  run-state state-bind state-modify state-pure)

(intrinsics:defn load-packages (std-path root-package-path binary-name)
  (def std (load-package-from std-path))
  ; TODO: Dependencies. I guess this is getting tossed out once it bootstraps
  ; oftc, so it doesn't _really_ matter, but /shrug.
  (def root (load-package-from root-package-path))

  (append
    (binary-component root binary-name)
    (append
      (library-component root)
      (library-component std))))

; Performs a post-order traversal over the modules, returning a result with
; the modules in order if the modules are acyclic, or the module involved in
; the cycle if they are not.
(intrinsics:defn traverse-modules (mods starting-module)
  ; Traverses to the given module. Returns a state-monadic computation with an
  ; ok value of nil on success, and a symbol (the module involved in the cycle)
  ; on error.
  (intrinsics:defn helper (goal)
    (def m (expect
      (find
        \(eq (index-into '(0 1) $) goal)
        mods)
      (string-append "No such module: " (symbol->string goal))))
    (def deps (map \(nth 1 $) (take-while \(shl? 'import $) (cdr m))))
    (panic deps))

  ; The state is the pair (closed set, module list).
  (def initial-state (pair empty-set nil))
  (def tmp (run-state initial-state (helper starting-module)))
  (if (nil? (fst tmp))
    (ok (snd (snd tmp)))
    (err (fst tmp))))
