(module macro-expander/modules
  [expand-modules module-name])

(import macro-expander/expand
  [expand-decls])
(import ministd/data/tree-set
  [list->set set-has?])

; Expands all the declarations in a module, returning a list of expanded modules.
(intrinsics:defn expand-module (target-module mod-srcs mods)
  ; The source of the target module.
  (def mod-src (expect
    (find \(equals (module-name $) target-module) mod-srcs)
    (string-append "Module not found: " (symbol->string target-module))))
  ; All import decls.
  (def imports (find-imports mod-src))
  ; A list of modules not yet in the mods assoc.
  (def missing-modules (filter
    \(none? (assoc $ mods))
    (map
      \(nth 1 $)
      imports)))
  (if (nil? missing-modules)
    ; If no modules are missing, build the environment and expand the declarations inside the
    ; module. Then, return the environment, as created from only the declarations inside the module
    ; (i.e. not including imports).
    (progn
      (def tmp (build-initial-env imports mods))
      (def interp-env (fst tmp))
      (def interp-macros (snd tmp))
      (def decls (find-decls mod-src))
      (expand-decls decls interp-env interp-macros))
    ; If there are missing modules, try expanding the first one, then try again with that one
    ; added.
    (progn
      (def new-mods (expand-module (car missing-modules) mod-srcs mods))
      (expand-module target-module mod-srcs new-mods))))

; Builds an initial environment from a list of import decls and an assoc of expanded module
; environments. Returns a pair (INTERP-ENV INTERP-MACROS).
(intrinsics:defn build-initial-env (imports mods)
  (def tmp (map \(process-import $ mods) imports))
  (if (nil? tmp)
    (pair nil nil)
    (panic (list 'todo (list 'build-initial-env imports 'mods)))))

; Returns the name of a module.
(intrinsics:defn module-name (m)
  (index-into '(0 1) m))

; Returns all the declarations from a module. (Really, just skips the module form and imports.)
(intrinsics:defn find-decls (m)
  (skip-while \(shl? 'import $) (cdr m)))

; Returns all the import forms from a module.
(intrinsics:defn find-imports (m)
  (take-while \(shl? 'import $) (cdr m)))

; Takes an import form and an assoc of already-expanded modules. Returns a list of pairs, where the
; fst is the imported value name and the snd is an either.  The left of the either is a value from
; interpreting the module. The right of the either is a function that runs the macro.
(intrinsics:defn process-import (imp mods)
  (def mod-name (nth 1 imp))
  (def plain-imports (vector->list (nth 2 imp)))
  (def attrs (skip 3 imp))

  (def m (expect
    (assoc mod-name mods)
    "Module not found, but this should've been caught already?"))

  (def no-import-decls (list->set (option->nullable
    (assoc 'no-import-decl attrs))))
  (def no-import-macros (list->set (option->nullable
    (assoc 'no-import-macro attrs))))

  (map
    \(progn
      (def f
        (if (set-has? $ no-import-decls)
          (if (set-has? $ no-import-macros)
            (panic (string-concat (list
              "Symbol "
              (symbol->string $)
              " was excluded from both decl and macro imports (from module "
              (symbol->string mod-name)
              ")")))
            process-import-macro)
          (if (set-has? $ no-import-macros)
            process-import-decl
            process-import-either)))
      (expect (f mod-name $ mods)
        (string-concat
          "Couldn't import "
          (symbol->string $)
          " from "
          (symbol->string mod-name))))
    plain-imports))

(intrinsics:defn process-import-decl (m name mods)
  (panic '(todo | process-import-decl)))

(intrinsics:defn process-import-either (m name mods)
  (def decl (process-import-decl m name mods))
  (def macro (process-import-macro m name mods))
  (panic '(todo | process-import-either)))

(intrinsics:defn process-import-macro (m name mods)
  (panic '(todo | process-import-macro)))

(intrinsics:defn expand-modules (mods-srcs)
  (expand-module 'main mods-srcs nil))
